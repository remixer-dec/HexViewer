<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>JS Hex Area Mapper</title>
	<script src="./lib/vue.min.js"></script>
	<style>
		body {
			display: block;
			font-family: monospace;
			margin: 0;
			padding: 0;
		}
		.main {
			display: flex;
			margin-top: 20px;
			flex-direction: row;
		}
		.hexview, .structureview {
			margin: 0 20px;	
			position: relative
		}
		.structureview {
			display: flex;
			flex-direction: column;
		}
		.newItem input, .newItem select {
			width: 180px;
			display: flex;
			margin: 10px;
			justify-content: center;
		}
		.save {
			position: fixed;
			right: 10px;
			bottom: 10px;
		}
		.fmview {
			position: fixed;
			border-bottom: 1px solid #eee;
			color: #777;
			left: 20px;
			top: 0;
			background: white;
		}
		.fmview div {
			display: inline-block;
			margin: 0 10px 2px 0;
		}
		.fmview span {
			cursor: pointer
		}
		#fileSelector {
			position: absolute;
			left: -100px;
			top: -100px;
			height: 0;
			width: 0;
		}
		.selected {
			color: #000;
			font-weight: 800;
		}
		span.close {
			color: #aaa;
			font-size: 10px;
			vertical-align: top;
			padding: 4px;
		}
		.intro {
			display: flex;
			width: 100%;
			height: 100%;
			justify-content: center;
			align-items: center;
			flex-direction: column;
		}
		.open {
			border-radius: 10px;
			border: 2px solid black;
			font-size: 16px;
			padding: 4px;
		}
		.arrow {
			position: absolute;
			left: -14px;
			font-size: 16px;
			cursor: pointer;
			user-select: none;
		}
		.arrow.arrow-up {
			transform: rotate(90deg);
			top: 0;
		}
		.arrow.arrow-down {
			bottom: 0;
			transform: rotate(-90deg);
			left: -15.6px;
		}
		span.scrollbar-wrapper {
			position: absolute;
			left: -14px;
			top: 14px;
			height: 100%;
			width: 10px;
			box-sizing: border-box;
			display: block;
			padding-bottom: 30px;
		}
		#scrollbar {
			width: 8px;
			display: block;
			background: #777;
			user-select: none;
			cursor: pointer
		}
	</style>
</head>
<body>
<div id="app">
	<input type="file" id="fileSelector" @change="fileSelected"/>
	<div v-if="file == false" class="intro">
		<h1>Hex Viewer + Area Mapper</h1>
		<label for="fileSelector" class="open">Open File</label>
		</div>
	<div v-else class="main">
		<div class="fmview">
			<div v-for="f in files" :class="{selected: selectedFile == f.name}">
				<span @click="selectFileFromTabs(f.name)">{{f.name}}</span><span class="close" @click="closeFile(f.name)">x</span>
			</div>
			<label for="fileSelector"><div><span>+</span></div></label>
		</div>
		<div class="hexview">
			<span class="arrow arrow-up" @mousedown="moveUp" @mouseup="stopMoving">&lt;</span>
			<span class="scrollbar-wrapper" id="scwrapper"><span id="scrollbar" :style="{height: scrollbarHeight, transform: `translateY(${scroll.pos}px)`}" @mousedown="scrollPicked"></span></span>
			<span class="arrow arrow-down" @mousedown="moveDown" @mouseup="stopMoving">&lt;</span>
			<span v-for="(b, index) in u8short" :key="index" class="bytes" :style="getAreaColors(offset + index)"><br v-if="index%16 == 0 && index != 0">{{normalize(b)}}
			<span class="row" v-if="index%4 == 0"></span></span>
		</div>
		<div class="textview">
			<span v-for="(b, index) in u8short" :key="index" class="text"><br v-if="index%16 == 0 && index != 0">{{String.fromCharCode(b)}}
			<span class="row" v-if="index%4 == 0"></span></span>
		</div>
		<div class="structureview">
			<div class="newItem">
				<input type="hidden" v-model="newItem.id">
				name:
				<input type="text" placeholder="area name" v-model="newItem.name"/>
				background color:
				<input type="color" v-model="newItem.bgcolor"/>
				foreground color:
				<input type="color" v-model="newItem.fgcolor"/>
				start:
				<select v-model="newItem.starttype">
					<option value="0">after previous block</option>
					<option value="1">at fixed value</option>
					<option value="2">defined at</option>
				</select>
				<input v-model="newItem.start" type="text" v-if="newItem.starttype == 1 || newItem.starttype == 2" />
				<select v-model="newItem.startint" v-if="newItem.starttype == 2">
					<option v-for="(i, index) in inttypes" :value="index">{{i}}</option>
				</select>
				type:
				<select v-model="newItem.type">
					<option>static</option>
					<option>variable</option>
					<option>dynamic</option>
				</select>
				size:
				<select v-model="newItem.sizetype">
					<option value="0">fixed</option>
					<option value="1">defined at</option>
				</select>
				<input type="text" v-model="newItem.size">
				<select v-model="newItem.sizeint" v-if="newItem.sizetype == 1">
					<option v-for="(i, index) in inttypes" :value="index">{{i}}</option>
				</select>
				<input type="button" value="ok" @click="addArea">
			</div>
			<div class="items" v-if="areas.length > 0">
				<table>
				<tr>
				  <th>#</th>
				  <th>Area</th>
				  <th>Start</th>
				  <th>Size</th>
				  <th>Action</th>
				</tr>
				<tr v-for="(area, index) in areas" :key="index">
					<td>{{index}}</td>
					<td :style="{backgroundColor: area.bgcolor, color: area.fgcolor}">{{area.name}}</td>
					<td>0x{{normalize(area._start, 6)}}</td>
					<td>{{area._size}}</td>
					<td @click=deleteArea(area.id)><button>delete</button></td>
				</tr>
				</table>
			</div>
			<button class="save" @click="downloadAreas()">Save schema</button>
		</div>
	</div>
</div>
	<script>
	const app = new Vue({
    'el': '#app',
    'data': {
    	file: false, 
    	u8: false,
    	files: [], 
    	areas: [],
    	inttypes: ["i08", "i16", "i24", "i32", "i64", "u08", "u16", "u24", "u32", "u64"], 
    	newItem: {
    		id: 0, 
    		name: '', 
    		bgcolor: '#ffffff', 
    		fgcolor: '#000000', 
    		type: 'static',
    		sizetype: 0, 
    		sizeint: 0, 
    		size: 0, 
    		starttype: 0, 
    		start: 0, 
    		startint: 0
    	}, 
    	maxColumns: 800, 
    	selectedFile: false, 
    	defaultColors: {backgroundColor: '#ffffff', color: '#000000'}, 
    	defaultItem: false, 
    	moving: false, 
    	offset: 0, 
    	scroll: {
    		wrapperHeight: this.scrollWrapperHeight, 
    		start: 0, 
    		startPos: 0, 
    		pos: 0, 
    		min: 0, 
    		max: 0,
    	}
    }, 
     mounted() {
     	this.defaultItem = Object.assign({}, this.newItem)
     }, 
    'computed': {
    	u8short() {
    		return this.u8.slice(this.offset, this.offset + this.maxColumns)
    	}, 
    	areaMap() {
    		let m = []
    		for (let area of this.areas) {
    			m.push([area._start, area._start + area._size, area.bgcolor, area.fgcolor])
    		}
    		return m
    	}, 
    	scrollbarHeight() {
    		let val = this.maxColumns / this.u8.length * 100
    		val = val < 1 ? 1 : val
    		val = val > 100 ? 100 : val
    		return val + "%"
    	}, 
    	scrollWrapperHeight() {
    		return scwrapper.offsetHeight - 36
    	}
    }, 
    'methods': {
    	addArea() {
    		this.areas.push(new AreaItem(this.newItem))
    		this.defaultItem.id++
    		this.newItem = Object.assign({}, this.defaultItem)
    	}, 
    	deleteArea(id) {
    		this.areas.splice(this.areas.findIndex(f => f.id == id), 1)
    	}, 
    	normalize(b, z=2) {
    		let o = b.toString(16).toUpperCase()
    		while (o.length < z) {
    			o = '0' + o
    		}
    		return o
    	}, 
    	fileSelected() {
    		if (fileSelector.files.length < 1) return
    		var reader = new FileReader()
    		reader.readAsArrayBuffer(fileSelector.files[0])
    		setTimeout(this.loadFile, 420, reader)
    	}, 
    	loadFile(reader) {
    		let f = fileSelector.files[0]
    		this.file = reader.result
    		this.offset = 0
    		this.u8 = new Uint8Array(this.file)
    		this.files.push({name: f.name, size: f.size, u8: this.u8, file: this.file})
    		this.selectedFile = f.name
    	}, 
    	selectFileFromTabs(name) {
    		let target = this.files.find(x => x.name == name)
    		this.file = target.file
    		this.u8 = target.u8
    		this.selectedFile = target.name
    		this.offset = this.offset + this.maxColumns < this.u8.length ? this.offset : 0
    	}, 
    	closeFile(name) {
    		if (this.files.length > 1) {
    			let index = this.files.findIndex(x => x.name == name)
    			this.files.splice(index, 1)
    			this.selectFileFromTabs(this.files[index > 0 ? index - 1 : 0].name)
    		} else {
    			this.files = []
    			this.file = false
    		}
    	}, 
    	getAreaColors(index) {
    		for (let i=0, l=this.areaMap.length; i<l; i++) {
    			let el = this.areaMap[i]
    			if (index >= el[0] && index < el[1]) {
    				return {backgroundColor: el[2], color: el[3]}
    			}
    		}
    		return this.defaultColors
    	},
    	readValue(offset, inttype=false) {
    		//TODO: implement inttype specific reading
    		return this.u8[offset]
    	}, 
    	downloadAreas() {
    		Downloader.downloadBlob(JSON.stringify(this.areas), 'areas.json')
    	},
    	getU8LengthMinusLastScreen() {
    		return (this.u8.length - (800 * (this.u8.length > 800)))
    	}, 
    	moveUp() {
    		this.stopMoving()
			this.moving = setInterval(() => {
				this.offset = this.offset > 16? this.offset - 16 : 0
				let percent = this.offset / this.getU8LengthMinusLastScreen() * 100
				this.scroll.pos = ((this.scrollWrapperHeight - scrollbar.offsetHeight) * percent / 100)
			}, 64)
    	}, 
    	moveDown() {
    		this.stopMoving()
    		this.moving = setInterval(() => {
    			let fl = this.getU8LengthMinusLastScreen()
    			this.offset =  this.offset < fl ? this.offset + 16 : this.offset
    			let percent = this.offset / fl * 100
				this.scroll.pos = ((this.scrollWrapperHeight - scrollbar.offsetHeight) * percent / 100)
				console.log(this.offset, fl)
				if (this.offset >= fl) clearInterval(this.moving)
    		}, 64)
    	}, 
    	stopMoving() {
    		clearInterval(this.moving)
    	},
    	scrollPicked(e) {
    		this.scroll.start = e.clientY
    		this.scroll.startPos = this.scroll.pos
    		this.scroll.min = 0
    		this.scroll.max = this.scrollWrapperHeight - scrollbar.offsetHeight
    		window.onmousemove = this.scrollMoved
    		window.onmouseup = this.scrollDroped
    	}, 
    	scrollMoved(e) {
    		let diff = e.clientY - this.scroll.start
    		let min = this.scroll.min - this.scroll.startPos
    		let max = this.scroll.max - this.scroll.startPos
    		diff = diff < min ? min : (diff > max? max : diff)
    		this.scroll.pos = this.scroll.startPos + diff
    	}, 
    	scrollDroped() {
    		window.onmousemove = false
    		window.onmouseup = false
    		let off = parseInt(this.scroll.pos / (this.scrollWrapperHeight-scrollbar.offsetHeight) * 100)
    		off = parseInt(this.getU8LengthMinusLastScreen() * off / 100)
    		off = off - (off % 16)
    		off = off > this.getU8LengthMinusLastScreen() ? this.getU8LengthMinusLastScreen() : off
    		this.offset = off
    	}
    }
    })
    
    class AreaItem {
    	constructor(cfgobj) {
    		for (let item in cfgobj) {
    			this[item] = cfgobj[item]
    		}
    		if (app.areas.length == 0) {
    			this._start = this.starttype == 0 ? 0 : parseInt(this.start, 16)
    			this._size = this.sizetype == 0 ? parseInt(this.size) : parseInt(this.size) /*TODO: implement reading start size*/
    		} else {
    			if (this.starttype == 0) { //after prev
					let prevItem = app.areas.find(a => a.id == app.defaultItem.id-1)
					this._start = prevItem._start + prevItem._size
				} else if (this.starttype == 1) { //fixed pos
					this._start = parseInt(this.start, 16)
				} else { //from addr
					this._start = app.readValue(this.start)
				}
				
				if (this.sizetype == 0) { //fixed size
					this._size = parseInt(this.size)
				} else {
					this._size = app.readValue(this.size)
				}
    		}
    	}
    }
    const Downloader = {
		downloadBlob: function(data, fileName, mimeType) {
			let blob, url
			blob = new Blob([data], {type: mimeType})
			url = window.URL.createObjectURL(blob)
			Downloader.downloadURL(url, fileName)
			setTimeout(function() {
				return window.URL.revokeObjectURL(url)
			}, 1000)
		},

		downloadURL: function(data, fileName) {
			let a = document.createElement('a')
			a.href = data
			a.download = fileName
			a.style = 'display: none'
			document.body.appendChild(a)
			a.click()
			a.remove()
		}
	}
	</script>
</body>
</html>